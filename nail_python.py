# Collections
"""
1) Tuples:  are immutable, ordered, iterable(linear time)
syntax: (5, 6, "Hello", "wow")
methods: 

2) Lists: are mutable, ordered, iterable(linear time)
syntax: [2, 4, "dff", "df"]
methods: len(mu_list), .append(), .insert(), .pop(), .remove()
.reverse(), .sort()

3) Dictionaries: have key-value pairs, are mutable, 
iterable(constant time), after python 3.7 they are ordered. 
syntax = {"dfsd": 2, "asd": 4}
methods: .keys(), .values(), .items(),.pop, del my_dict['key]

4) Sets: are fast, unique values, mutable, unordered,
iterable(constant time)
methods: .add(), .update(), .remove(), .intersection()
.difference()
"""
# Time complexity
"""
O(1): Constant time
ex: {"dfsd": 2, "asd": 4} accessing is any element in O(1)

O(n): Linear time
ex: [2, 4, "dff", "df"] Iterating through a list take O(n)

O(log n): ex: Binary search

O(n^2): quadratic
ex: Two nested for loops

"""
# Recursion
"""
1) Divide a problem into subproblems
2) Solve those subproblems
3) Combine the results to solve the original problems
"""
# OOP
"""
Look for OOP program in misc.
Encapsulation
Inheritance
Polymorphism
"""
